---
title: 2025年の纏まり
author: zhangyile
date: 2025-12-06 13:42:00 +0800
categories: [Work Log]
tags: [Work,Development]
comments: false
img_path: /assets/img/
image:
  path: company_without/isogashii_man.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: Responsive rendering of Chirpy theme on multiple devices.
---

## LINQについて性能問題

動画URL: https://www.bilibili.com/video/BV1DkUsB6EVQ

```
//毎回に新しいリストが生成される
targets = targets.Where(x => x.JobType == EJobType.Melee).ToList();

//必要なアイテムを残す
public static void FilterListElementInPlace(List<Avatar> list)
{
    int writeIndex = 0;
    for (int readIndex = 0; readIndex < list.Count; readIndex++)
    {
        var one = list[readIndex];
        if (one.JobType == EJobType.Melee)
        {
            list[writeIndex] = one;
            writeIndex++;
        }
    }
    if(writeIndex < list.Count)
        list.RemoveRange(writeIndex, list.Count - writeIndex);
}

```


## **ラムダ式の変数束縛で罠**
動画URL: https://www.bilibili.com/video/BV14cCdBGEyq
動画URL: https://qiita.com/hiki_neet_p/items/8efc80739657b52922c7

```
List<Action> actions = new List<Action>();

for(int i = 0; i < 3;i++)
{
    action.Add(()=> Debug.Log(i));
}

foreach(var action in actions)
{
    action();//???
}
```

## UniTaskの差し替え

```
private async UniTask PlayCoinSE(float delayTime)
{
    await UniTask.WaitForSeconds(delayTime);
    Context.audioSystem.PlaySESound(CoinSE);
    //↓↓↓↓↓↓↓↓↓↓↓
    DOVirtual.DelayedCall(delayTime, () =>
    {
        Context.audioSystem.PlaySESound(TreasureSE);
    });
}
```

## Hook Unity

動画URL: 実行中にTransformのPositionがどのスクリプトに弄られるかという質問がよくあります

https://github.com/V4SS3UR/DetourUtility


## Decorator Pattern

動画URL: https://www.bilibili.com/video/BV1YHyZB8Ebq

動画URL: https://www.youtube.com/watch?v=o5Iwu5wpINQ


## Combinator Pattern

動画URL: https://www.youtube.com/watch?v=pPHdF2r6TmU

## Hierarchyにカスタマイズアイコンを追加する

動画URL: https://youtu.be/OidPCs1YECo?si=7vGcGLmtHY3dA9u3

### Inspector上で属性を表示する

```
[CustomPropertyDrawer(typeof(RequiredFieldAttribute))]
public class RequiredFieldDrawer : PropertyDrawer
{
		Texture2D requiredIcon = AssetDatabase.
		LoadAssetAtPath<Texture2D>("Assets/_Project/Art/RequiredIcon.png");
		
		public override void OnGUI(
			Rect position,
			SerializedProperty property,
			GUIContent label)
		{
		
		}
}
```

### Hierarchy上でアイコンを表示する

```
public static class ObjectPoolIcon
{

}
```

## C#トリック

### コンパイラ

```
//関数の呼ばれる経緯を記録する
[CallerMemberName] string methodName;
[CallerFilePath] string filePath;
[CallerLineNumber] int lineNumber;

//関数をinlineにする、関数の呼び「手間、コスト、消費」を減らす
[MethodImpl(MethodImplOptions.AggressiveInlining)]
private float Multiply(float a, float b)
{
    return a * b;
}
```

### 配列

```
int[] scores = {10,20,30,40,50}
int last = scores[^1];
int last3 = scores[^3..];
int first2 = scores[..2];
int[] mid = scores[1..4];
```



1. UI上显示曲线
继承 Graphic
[RequireComponent(typeof(CanvasRenderer))]
class UISpline : Graphic
{
    public override void OnPopulateMesh(VertexHelper vh)
    {//生成自己的网格
        //根据贝塞尔曲线 绘制网格 UI
    }

    //1. 计算二次贝塞尔曲线
    //2. 获取曲线的点
    //3. 根据点 生成网格
    //4. 计算UV
}

2. 组合器模式
using CanTarget = And<And<InRange,IsAlive>,LineOfSight>
class Targeting : MonoBehaviour
{
    void Update()
    {
        var pred = PreChain
            .Start(new InRange())
            .And(new IsAlive())
            .And(new LineOfSight())
            .Build();

        var ctx = new TargetCtx();
        pred.Test(enemy,ctx);
    }
}


//保存上下文
struct TargetCtx
{
    public readonly Vector3 origin
    public TargetCtx(Vector3 origin)
    {
        this.origin = origin;
    }
}

//启动方法
static class PreChain
{
    public static Chain<TLeaf> Start<TLeaf>(TLeaf leaf) where TLeaf : struct,IPred
    {
        return new Chain<TLeaf>(leaf);
    }
     
}

//链式调用
readonly struct Chain<TPred> where TPred : struct,IPred
{
    public readonly TPred p;
    public Chain(TPred p)
    {
        this.p = p;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Chain<And<TPred,TNext>> And<TNext>(TNext n) where TNext : struct,IPred
    {
        var t = new And<TPred,TNext>(this.p,n);
        return new Chain(t);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Chain<Or<TPred,TNext>> Or<TNext>(TNext n) where TNext : struct,IPred
    {
        var t = new Or<TPred,TNext>(this.p,n);
        return new Chain(t);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Chain<Not<TPred,TNext>> Not<TNext>(TNext n) where TNext : struct,IPred
    {
        var t = new Not<TPred,TNext>(this.p,n);
        return new Chain(t);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TPred Build() => p;
}

//
readonly struct Not<A> : IPred
{
    public readonly A a;
    public Not(A a)
    {
        this.a = a;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Test(Enemy e,in TargetCtx c)
    {
        return !a.Test(e,c);
    }
}

//组合
readonly struct Or<A,B> : IPred
    where A : struct, IPred
    where B : struct, IPred
{
    public readonly A a;
    public readonly B b;

    public Or(A a,B b)
    {
        this.a = a;
        this.b = b;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Test(Enemy e,in TargetCtx c)
    {
        return a.Test(e,c) || b.Test(e,c);
    }
}

readonly struct And<A,B> : IPred
    where A : struct, IPred
    where B : struct, IPred
{
    public readonly A a;
    public readonly B b;

    public And(A a,B b)
    {
        this.a = a;
        this.b = b;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Test(Enemy e,in TargetCtx c)
    {
        return a.Test(e,c) && b.Test(e,c);
    }
}

//叶子节点
public interface IPred
{
    //in 和 ref 是针对struct结构体传递时候的优化
    bool Test(Enemy e,in TargetCtx c);
}

readonly struct InRange : IPred
{
    //希望在JIT期间内联函数
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Test(Enemy e,in TargetCtx c)
    {
        return (e.transform.position - c.origin).sqrMagnitude <= c.r2;
    }
}

readonly struct LineOfSight : IPred
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Test(Enemy e,in TargetCtx c)
    {
        return (e.transform.position - c.origin).sqrMagnitude <= c.r2;
    }
}

readonly struct IsAlive : IPred
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Test(Enemy e,in TargetCtx c)
    {
        return e.health > 0;
    }
}

