---
title: 2025年の纏まり
author: zhangyile
date: 2025-12-06 13:42:00 +0800
categories: [Work Log]
tags: [Work,Development]
comments: false
img_path: /assets/img/
image:
  path: company_without/isogashii_man.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: Responsive rendering of Chirpy theme on multiple devices.
---

## LINQについて性能問題

動画URL: https://www.bilibili.com/video/BV1DkUsB6EVQ

```
//毎回に新しいリストが生成される
targets = targets.Where(x => x.JobType == EJobType.Melee).ToList();

//必要なアイテムを残す
public static void FilterListElementInPlace(List<Avatar> list)
{
    int writeIndex = 0;
    for (int readIndex = 0; readIndex < list.Count; readIndex++)
    {
        var one = list[readIndex];
        if (one.JobType == EJobType.Melee)
        {
            list[writeIndex] = one;
            writeIndex++;
        }
    }
    if(writeIndex < list.Count)
        list.RemoveRange(writeIndex, list.Count - writeIndex);
}

```


## **ラムダ式の変数束縛で罠**
動画URL: https://www.bilibili.com/video/BV14cCdBGEyq
動画URL: https://qiita.com/hiki_neet_p/items/8efc80739657b52922c7

```
List<Action> actions = new List<Action>();

for(int i = 0; i < 3;i++)
{
    action.Add(()=> Debug.Log(i));
}

foreach(var action in actions)
{
    action();//???
}
```

## UniTaskの差し替え

```
private async UniTask PlayCoinSE(float delayTime)
{
    await UniTask.WaitForSeconds(delayTime);
    Context.audioSystem.PlaySESound(CoinSE);
    //↓↓↓↓↓↓↓↓↓↓↓
    DOVirtual.DelayedCall(delayTime, () =>
    {
        Context.audioSystem.PlaySESound(TreasureSE);
    });
}
```

## Hook Unity

動画URL: 実行中にTransformのPositionがどのスクリプトに弄られるかという質問がよくあります

https://github.com/V4SS3UR/DetourUtility


## Decorator Pattern

動画URL: https://www.bilibili.com/video/BV1YHyZB8Ebq

動画URL: https://www.youtube.com/watch?v=o5Iwu5wpINQ


## Combinator Pattern

動画URL: https://www.youtube.com/watch?v=pPHdF2r6TmU

## Hierarchyにカスタマイズアイコンを追加する

動画URL: https://youtu.be/OidPCs1YECo?si=7vGcGLmtHY3dA9u3

### Inspector上で属性を表示する

```
[CustomPropertyDrawer(typeof(RequiredFieldAttribute))]
public class RequiredFieldDrawer : PropertyDrawer
{
		Texture2D requiredIcon = AssetDatabase.
		LoadAssetAtPath<Texture2D>("Assets/_Project/Art/RequiredIcon.png");
		
		public override void OnGUI(
			Rect position,
			SerializedProperty property,
			GUIContent label)
		{
		
		}
}
```

### Hierarchy上でアイコンを表示する

```
public static class ObjectPoolIcon
{

}
```

## C#トリック

### コンパイラ

```
//関数の呼ばれる経緯を記録する
[CallerMemberName] string methodName;
[CallerFilePath] string filePath;
[CallerLineNumber] int lineNumber;

//関数をinlineにする、関数の呼び「手間、コスト、消費」を減らす
[MethodImpl(MethodImplOptions.AggressiveInlining)]
private float Multiply(float a, float b)
{
    return a * b;
}
```

### 配列

```
int[] scores = {10,20,30,40,50}
int last = scores[^1];
int last3 = scores[^3..];
int first2 = scores[..2];
int[] mid = scores[1..4];
```


## StateMachine

```
public interface IState
{
	void Enter();
	void Update();
	void FixedUpdate();
	void Exit();
}

public interface IPredicate
{
	bool Evaluate();
}

public interface ITransition
{
	IState To {get;}
	IPredicate Condition {get;}
}


public abstract class BaseState : IState
{
	protected readonly AvatarController controller;

	public BaseState(AvatarController inController)
	{
		controller = inController;
	}

	public virtual void Enter()
	{

	}

	public virtual void Update()
	{

	}

	public virtual void FixedUpdate()
	{

	}

	public virtual void Exit()
	{

	}
}


public class FuncPredicate : IPredicate
{
	readonly Func<bool> func;

	public FuncPredicate(Func<bool> inFunc)
	{
		func = inFunc;
	}

	public bool Evaluate()
	{
		return func.Invoke();
	}
}


public class Transition : ITransition
{
	public IState To {get;}
	public IPredicate Condition {get;}

	public Transition(IState to,IPredicate condition){
		To = to;
		Condition = condition;
	}
}


public class StateMachine
{
	StateNode current;

	Dictionary<Type,StateNode> nodes = new();
	HashSet<ITransition> anyTransitions = new();

	class StateNode 
	{
		public IState State {get;}
		public HashSet<ITransition> Transitions{get;}
		
		public StateNode(IState state)
		{
			State = state;
			Transitions = new HashSet<ITransition>();
		}

		public void AddTransition(IState to,IPredicate condition)
		{
			Transitions.Add(new Transition(to,condition));
		}
	}

	void ChangeState(IState state)
	{
		if(state == current.state) return;

		var previousState = current.State;
		var nextState = nodes[state.getType()].State;

		previousState.Exit();
		nextState.Enter();
		current = nodes[state.getType()];
	}

	public void Update()
	{
		var transiton = GetTransition();
		if(transiton != null)
			ChangeState(transiton.To);

		current.State.Update();
	}

	public void FixedUpdate()
	{
		current.State.FixedUpdate();
	}

	ITransition GetTransition()
	{

	}
}

```

## Combinator

```
2. 组合器模式
using CanTarget = And<And<InRange,IsAlive>,LineOfSight>
class Targeting : MonoBehaviour
{
    void Update()
    {
        var pred = PreChain
            .Start(new InRange())
            .And(new IsAlive())
            .And(new LineOfSight())
            .Build();

        var ctx = new TargetCtx();
        pred.Test(enemy,ctx);
    }
}


//保存上下文
struct TargetCtx
{
    public readonly Vector3 origin
    public TargetCtx(Vector3 origin)
    {
        this.origin = origin;
    }
}

//启动方法
static class PreChain
{
    public static Chain<TLeaf> Start<TLeaf>(TLeaf leaf) where TLeaf : struct,IPred
    {
        return new Chain<TLeaf>(leaf);
    }
     
}

//链式调用
readonly struct Chain<TPred> where TPred : struct,IPred
{
    public readonly TPred p;
    public Chain(TPred p)
    {
        this.p = p;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Chain<And<TPred,TNext>> And<TNext>(TNext n) where TNext : struct,IPred
    {
        var t = new And<TPred,TNext>(this.p,n);
        return new Chain(t);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Chain<Or<TPred,TNext>> Or<TNext>(TNext n) where TNext : struct,IPred
    {
        var t = new Or<TPred,TNext>(this.p,n);
        return new Chain(t);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Chain<Not<TPred,TNext>> Not<TNext>(TNext n) where TNext : struct,IPred
    {
        var t = new Not<TPred,TNext>(this.p,n);
        return new Chain(t);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TPred Build() => p;
}

//
readonly struct Not<A> : IPred
{
    public readonly A a;
    public Not(A a)
    {
        this.a = a;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Test(Enemy e,in TargetCtx c)
    {
        return !a.Test(e,c);
    }
}

//组合
readonly struct Or<A,B> : IPred
    where A : struct, IPred
    where B : struct, IPred
{
    public readonly A a;
    public readonly B b;

    public Or(A a,B b)
    {
        this.a = a;
        this.b = b;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Test(Enemy e,in TargetCtx c)
    {
        return a.Test(e,c) || b.Test(e,c);
    }
}

readonly struct And<A,B> : IPred
    where A : struct, IPred
    where B : struct, IPred
{
    public readonly A a;
    public readonly B b;

    public And(A a,B b)
    {
        this.a = a;
        this.b = b;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Test(Enemy e,in TargetCtx c)
    {
        return a.Test(e,c) && b.Test(e,c);
    }
}

//叶子节点
public interface IPred
{
    //in 和 ref 是针对struct结构体传递时候的优化
    bool Test(Enemy e,in TargetCtx c);
}

readonly struct InRange : IPred
{
    //希望在JIT期间内联函数
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Test(Enemy e,in TargetCtx c)
    {
        return (e.transform.position - c.origin).sqrMagnitude <= c.r2;
    }
}

readonly struct LineOfSight : IPred
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Test(Enemy e,in TargetCtx c)
    {
        return (e.transform.position - c.origin).sqrMagnitude <= c.r2;
    }
}

readonly struct IsAlive : IPred
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Test(Enemy e,in TargetCtx c)
    {
        return e.health > 0;
    }
}

```

 
class Base
{
    int id;
    Vector2 size;
}

interface BaseInterface
{
    int GetId();
    Vector2 GetSize();
}

class ConfidentBase : BaseInterface
{
    Base base;
    int GetId()
    {
        base.id;
    }
    Vector2 GetSize()
    {
        return base.size;
    }
}

List<ConfidentBase> baseList;


class Test
{
    private static int leftCount;
    private static int earnedCount;

    public Test(InGameContexts context)
    {
        leftCount = context.getLeftCount();
        earnedCount = 0;
    }
}

List<Object> baseList;

void async UniTask GetObject()
{
    baseList.
}


public void ChangeHomeModeImmediate()
{
    home.SetActive(true);
    state = GlobalFooterState.Home;
    IsOperationValid = true;
}

private void OnClickBack()
{
    UniTask ShowFooter()
    {
        globalFooter.ChangeHomeModeImmediate();
        return UniTask.CompletedTask;
    }
}